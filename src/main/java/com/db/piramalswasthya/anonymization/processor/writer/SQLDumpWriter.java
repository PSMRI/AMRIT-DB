package com.db.piramalswasthya.anonymization.processor.writer;

import com.db.piramalswasthya.anonymization.exception.AnonymizationException;
import com.db.piramalswasthya.anonymization.processor.model.SQLStatement;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.BufferedWriter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.util.List;
import java.util.zip.GZIPOutputStream;

/**
 * Writes SQL statements to a dump file.
 * Supports both plain .sql and compressed .sql.gz formats.
 * Uses buffered writing for performance with large dumps.
 */
@Slf4j
public class SQLDumpWriter implements AutoCloseable {
    private static final Logger log = LoggerFactory.getLogger(SQLDumpWriter.class);
    private final Path outputPath;
    private final BufferedWriter writer;
    private long statementsWritten = 0;
    private long bytesWritten = 0;
    private boolean headerWritten = false;
    
    /**
     * Create a writer for SQL dump output
     * 
     * @param outputPath Path to output .sql or .sql.gz file
     * @throws AnonymizationException if file cannot be created
     */
    public SQLDumpWriter(Path outputPath) throws AnonymizationException {
        this.outputPath = outputPath;
        
        try {
            // Create parent directories if needed
            if (outputPath.getParent() != null) {
                outputPath.getParent().toFile().mkdirs();
            }
            
            // Detect compression from extension
            if (outputPath.toString().endsWith(".gz")) {
                log.info("Creating compressed SQL dump: {}", outputPath);
                this.writer = new BufferedWriter(
                    new OutputStreamWriter(
                        new GZIPOutputStream(new FileOutputStream(outputPath.toFile())),
                        StandardCharsets.UTF_8
                    ),
                    65536 // 64KB buffer
                );
            } else {
                log.info("Creating SQL dump: {}", outputPath);
                this.writer = new BufferedWriter(
                    new OutputStreamWriter(
                        new FileOutputStream(outputPath.toFile()),
                        StandardCharsets.UTF_8
                    ),
                    65536 // 64KB buffer
                );
            }
            
        } catch (IOException e) {
            throw new AnonymizationException("Failed to create SQL dump file: " + outputPath, e);
        }
    }
    
    /**
     * Write dump file header with metadata
     */
    public void writeHeader(String sourceDatabase, String toolVersion) throws AnonymizationException {
        if (headerWritten) {
            return;
        }
        
        try {
            writer.write("-- AMRIT Anonymized Database Dump\n");
            writer.write("-- Generated by: AMRIT Anonymization Tool v" + toolVersion + "\n");
            writer.write("-- Source: " + sourceDatabase + "\n");
            writer.write("-- Date: " + java.time.Instant.now() + "\n");
            writer.write("-- WARNING: This dump contains anonymized data for UAT testing only\n");
            writer.write("-- DO NOT use this dump to restore production data\n");
            writer.write("\n");
            writer.write("SET NAMES utf8mb4;\n");
            writer.write("SET FOREIGN_KEY_CHECKS = 0;\n");
            writer.write("\n");
            
            headerWritten = true;
            
        } catch (IOException e) {
            throw new AnonymizationException("Failed to write dump header", e);
        }
    }
    
    /**
     * Write a complete SQL statement
     */
    public void writeStatement(SQLStatement statement) throws AnonymizationException {
        try {
            String sql = statement.getOriginalSQL();
            
            // Add newline before statement for readability
            if (statementsWritten > 0) {
                writer.write("\n");
            }
            
            writer.write(sql);
            
            // Ensure semicolon at end
            if (!sql.trim().endsWith(";")) {
                writer.write(";");
            }
            
            writer.write("\n");
            
            statementsWritten++;
            bytesWritten += sql.length() + 2; // +2 for newlines
            
            // Flush periodically to avoid excessive buffering
            if (statementsWritten % 1000 == 0) {
                writer.flush();
                log.debug("Written {} statements, {} bytes", statementsWritten, bytesWritten);
            }
            
        } catch (IOException e) {
            throw new AnonymizationException("Failed to write SQL statement at statement #" + statementsWritten, e);
        }
    }
    
    /**
     * Write an INSERT statement with anonymized data
     */
    public void writeInsert(String databaseName, String tableName, 
                           List<String> columnNames, List<List<String>> rowValues) 
                           throws AnonymizationException {
        try {
            // Build INSERT statement
            StringBuilder sql = new StringBuilder();
            sql.append("INSERT INTO `").append(databaseName).append("`.`").append(tableName).append("` ");
            
            // Column names (optional, but recommended)
            if (columnNames != null && !columnNames.isEmpty()) {
                sql.append("(");
                for (int i = 0; i < columnNames.size(); i++) {
                    if (i > 0) sql.append(", ");
                    sql.append("`").append(columnNames.get(i)).append("`");
                }
                sql.append(") ");
            }
            
            sql.append("VALUES ");
            
            // Rows
            for (int rowIdx = 0; rowIdx < rowValues.size(); rowIdx++) {
                List<String> row = rowValues.get(rowIdx);
                
                if (rowIdx > 0) {
                    sql.append(", ");
                }
                
                sql.append("(");
                for (int colIdx = 0; colIdx < row.size(); colIdx++) {
                    if (colIdx > 0) sql.append(", ");
                    sql.append(escapeValue(row.get(colIdx)));
                }
                sql.append(")");
            }
            
            sql.append(";");
            
            // Write the statement
            writer.write(sql.toString());
            writer.write("\n");
            
            statementsWritten++;
            bytesWritten += sql.length() + 1;
            
            // Flush periodically
            if (statementsWritten % 1000 == 0) {
                writer.flush();
            }
            
        } catch (IOException e) {
            throw new AnonymizationException("Failed to write INSERT statement for " + 
                databaseName + "." + tableName, e);
        }
    }
    
    /**
     * Escape a value for SQL output
     */
    private String escapeValue(String value) {
        if (value == null) {
            return "NULL";
        }
        
        // If value is already a number, keep as-is
        if (value.matches("-?\\d+(\\.\\d+)?")) {
            return value;
        }
        
        // If value is NULL keyword, keep as-is
        if ("NULL".equalsIgnoreCase(value)) {
            return "NULL";
        }
        
        // String value - escape and quote
        String escaped = value
            .replace("\\", "\\\\")  // Backslash
            .replace("'", "\\'")     // Single quote
            .replace("\"", "\\\"")   // Double quote
            .replace("\n", "\\n")    // Newline
            .replace("\r", "\\r")    // Carriage return
            .replace("\t", "\\t");   // Tab
        
        return "'" + escaped + "'";
    }
    
    /**
     * Write a comment line
     */
    public void writeComment(String comment) throws AnonymizationException {
        try {
            writer.write("-- ");
            writer.write(comment);
            writer.write("\n");
        } catch (IOException e) {
            throw new AnonymizationException("Failed to write comment", e);
        }
    }
    
    /**
     * Write dump file footer
     */
    public void writeFooter() throws AnonymizationException {
        try {
            writer.write("\n");
            writer.write("SET FOREIGN_KEY_CHECKS = 1;\n");
            writer.write("\n");
            writer.write("-- End of anonymized dump\n");
            writer.write("-- Statements written: " + statementsWritten + "\n");
            writer.write("-- Bytes written: " + bytesWritten + "\n");
            
        } catch (IOException e) {
            throw new AnonymizationException("Failed to write dump footer", e);
        }
    }

    public void flush() throws AnonymizationException {
        try {
            writer.flush();
        } catch (IOException e) {
            throw new AnonymizationException("Failed to flush writer", e);
        }
    }

    public long getStatementsWritten() {
        return statementsWritten;
    }

    public long getBytesWritten() {
        return bytesWritten;
    }

    @Override
    public void close() throws AnonymizationException {
        try {
            if (writer != null) {
                writer.flush();
                writer.close();
                log.info("SQL dump written: {} statements, {} bytes", statementsWritten, bytesWritten);
            }
        } catch (IOException e) {
            throw new AnonymizationException("Failed to close SQL dump writer", e);
        }
    }
}
